package org.cryptocoinpartners.schema;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import javax.annotation.Nullable;import javax.persistence.Basic;import javax.persistence.Cacheable;import javax.persistence.CascadeType;import javax.persistence.Entity;import javax.persistence.FetchType;import javax.persistence.JoinColumn;import javax.persistence.ManyToOne;import javax.persistence.MapKeyJoinColumn;import javax.persistence.NamedQueries;import javax.persistence.NamedQuery;import javax.persistence.OneToMany;import javax.persistence.Transient;import org.cryptocoinpartners.enumeration.ExecutionInstruction;import org.cryptocoinpartners.enumeration.FeeMethod;import org.cryptocoinpartners.enumeration.PersistanceAction;import org.cryptocoinpartners.schema.dao.Dao;import org.cryptocoinpartners.schema.dao.ExchangeJpaDao;import org.cryptocoinpartners.util.ConfigUtil;import org.cryptocoinpartners.util.EM;import com.google.inject.Inject;import com.google.inject.assistedinject.Assisted;import com.google.inject.assistedinject.AssistedInject;/** * @author Tim Olson */@Entity@Cacheable@NamedQueries({ @NamedQuery(name = "Exchange.findExchange", query = "select e from Exchange e where symbol =?1") })///*@NamedEntityGraphs({		// @NamedEntityGraph(name = "orderWithParentFill", attributeNodes = { @NamedAttributeNode(value = "parentFill", subgraph = "orderWithParentFillDetails") }, subgraphs = { @NamedSubgraph(name = "orderWithParentFillDetails", attributeNodes = { @NamedAttributeNode("children") }) }),		@NamedEntityGraph(name = "exchangeWithBalances", attributeNodes = { @NamedAttributeNode(value = "balances") })		//@NamedSubgraph(name = "fills", attributeNodes = @NamedAttributeNode(value = "fills", subgraph = "order"))		//,@NamedSubgraph(name = "order", attributeNodes = @NamedAttributeNode("order")) })*/public class Exchange extends EntityBase {	/**	   * 	   */	//private static final long serialVersionUID = 4151431428629882383L;	private static Map<String, Exchange> exchangeMap = new HashMap<String, Exchange>();	/**	   * 	   */	// @Inject	//protected static ExchangeJpaDao exchangeDao;	@Inject	protected transient static ExchangeJpaDao exchangeDao;	@Inject	protected transient static TransactionFactory transactionFactory;	@Inject	protected transient static ExchangeFactory exchangeFactory;	private Map<Asset, Balance> balances;	public static Exchange forSymbolOrCreate(String symbol) {		Exchange found = forSymbol(symbol);		if (found == null) {			found = exchangeFactory.create(symbol);			//    new Exchange(symbol);			//found.setRevision(found.getRevision() + 1);			exchangeMap.put(symbol, found);			try {				exchangeDao.persistEntities(false, found);			} catch (Throwable e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}		//  if (found.getBalances().isEmpty())		//     loadBalances(found);		return found;	}	@Override	@Transient	public EntityBase getParent() {		return null;	}	public void loadBalances(Portfolio portfolio) {		final String configPrefix = "xchange";		//  Set<String> exchangeTags = XchangeUtil.getExchangeTags();		// for (String tag : exchangeTags) {		//     if (this.equals(XchangeUtil.getExchangeForTag(tag))) {		// three configs required:		// .class the full classname of the Xchange implementation		// .rate.queries rate limit the number of queries to this many (default: 1)		// .rate.period rate limit the number of queries during this period of time (default: 1 second)		// .listings identifies which Listings should be fetched from this exchange		String prefix = configPrefix + "." + getSymbol().toLowerCase() + '.';		if (getBalances() == null || getBalances().isEmpty()) {			log.info(this.getClass().getSimpleName() + "- Balances are empty loading from combined config.");			List balances = ConfigUtil.combined().getList(prefix + "balances", null);			if (balances == null || balances.isEmpty()) {				log.info(this.getClass().getSimpleName() + "- Balances: + " + balances + " exiting load.");				return;			}			// final List listings = config.getList(prefix + "listings");			log.info(this.getClass().getSimpleName() + "- Balances: + " + balances + " itterating over.");			for (Iterator<List> il = balances.iterator(); il.hasNext();) {				Object balanceSymbol = il.next();				Balance balance = Balance.forSymbol(this, balanceSymbol.toString().toUpperCase());				if (balance.getAsset() == null || balance.getExchange() == null || balance.getAmount() == null)					continue;				balance.persit();				addBalance(balance);				//this.addBalance(balance);				log.info("Exchange: Added Balance " + balance + " to exchnage " + this);				// DiscreteAmount price = new DiscreteAmount(0, balance.getAsset().getBasis());				// Transaction initialCredit = transactionFactory.create(portfolio, balance.getExchange(), balance.getAsset(), TransactionType.CREDIT,				//       balance.getAmount(), price);				//portfolio.getContext().setPublishTime(initialCredit);				//initialCredit.persit();				//portfolio.getContext().publish(initialCredit);				// market = context.getInjector().getInstance(Market.class).findOrCreate(coinTraderExchange, listing);				//markets.add(market);			}		}		this.merge();		// replace all markets with this		for (Tradeable tradeable : Portfolio.getMarkets()) {			if (!tradeable.isSynthetic()) {				Market market = (Market) tradeable;				if (market.getExchange().equals(this))					market.setExchange(this);			}		}		//this.merge();		/*		 * // } else { log.info("Loading balances from persitance \"xchange." + this + ".*\""); for (Iterator<Asset> il =		 * getBalances().keySet().iterator(); il.hasNext();) { Asset balanceSymbol = il.next(); //balance.persit(); //this.addBalance(balance);		 * log.debug("Exchange: publishing Balance " + getBalances().get(balanceSymbol) + " to exchnage " + this); DiscreteAmount price = new		 * DiscreteAmount(0, balanceSymbol.getBasis()); Transaction initialCredit = transactionFactory.create(portfolio, this, balanceSymbol,		 * TransactionType.CREDIT, getBalances().get(balanceSymbol) .getAmount(), price); portfolio.getContext().setPublishTime(initialCredit);		 * initialCredit.persit(); portfolio.getContext().publish(initialCredit); // market =		 * context.getInjector().getInstance(Market.class).findOrCreate(coinTraderExchange, listing); //markets.add(market); } }		 */		//  }		//  }	}	public static Exchange forSymbolOrCreate(String symbol, int margin, double makerFeeRate, double takerFeeRate, double feeBasis, double orderBasis,			FeeMethod feeMethod, boolean fillsProvided) {		Exchange found = forSymbol(symbol);		if (found == null) {			found = exchangeFactory.create(symbol, margin, makerFeeRate, takerFeeRate, feeBasis, orderBasis, feeMethod, fillsProvided);			//found.setRevision(found.getRevision() + 1);			exchangeMap.put(symbol, found);			try {				exchangeDao.persistEntities(false, found);			} catch (Throwable e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}		//  if (found.getBalances().isEmpty())		//    loadBalances(found);		return found;	}	public static Exchange forSymbolOrCreate(String symbol, int margin, double makerFeeRate, double takerFeeRate, double feeBasis, double orderBasis,			FeeMethod feeMethod, double marginFeeRate, double minimumOrderSize, FeeMethod marginFeeMethod, boolean fillsProvided) {		Exchange found = forSymbol(symbol);		if (found == null) {			found = exchangeFactory.create(symbol, margin, makerFeeRate, takerFeeRate, feeBasis, orderBasis, feeMethod, marginFeeRate, marginFeeMethod,					minimumOrderSize, fillsProvided);			//found.setRevision(found.getRevision() + 1);			exchangeMap.put(symbol, found);			try {				exchangeDao.persistEntities(false, found);			} catch (Throwable e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			// exchangeDao.persist(found);		}		// if (found.getBalances().isEmpty())		//   loadBalances(found);		return found;	}	/** returns null if the symbol does not represent an existing exchange */	public static Exchange forSymbol(String symbol) {		if (exchangeMap.get(symbol) == null) {			Exchange exchange = EM.queryZeroOne(Exchange.class, "select e from Exchange e where symbol=?1", symbol);			if (exchange != null) {				exchange.setPersisted(true);				exchangeMap.put(symbol, exchange);			}		}		return exchangeMap.get(symbol);	}	public static List<String> allSymbols() {		return EM.queryList(String.class, "select symbol from Exchange");	}	@Basic(optional = false)	public String getSymbol() {		return symbol;	}	@Transient	@Basic(optional = false)	public double getFeeRate(ExecutionInstruction executionInstruction) {		if (executionInstruction != null && executionInstruction.equals(ExecutionInstruction.MAKER))			return makerFeeRate;		else			return takerFeeRate;	}	@Basic(optional = false)	public double getTakerFeeRate() {		return takerFeeRate;	}	@Basic(optional = false)	public double getMakerFeeRate() {		return makerFeeRate;	}	@Transient	public double getFeeBasis(Tradeable market) {		if (feeBasis == 0)			return market.getPriceBasis();		else			return feeBasis;	}	@Transient	public double getFeeBasis(Exchange excahnge) {		return feeBasis;	}	public double getOrderBasis(Tradeable market) {		if (orderBasis == 0)			return market.getVolumeBasis();		else			return orderBasis;	}	public double getMinimumOrderSize(Tradeable market) {		if (minimumOrderSize == 0)			return market.getVolumeBasis();		else			return minimumOrderSize;	}	@Basic(optional = false)	private double getOrderBasis() {		return orderBasis;	}	@Basic(optional = false)	private double getFeeBasis() {		return feeBasis;	}	protected synchronized void setFeeBasis(double feeBasis) {		this.feeBasis = feeBasis;	}	protected synchronized void setOrderBasis(double orderBasis) {		this.orderBasis = orderBasis;	}	protected synchronized void setTakerFeeRate(double takerFeeRate) {		this.takerFeeRate = takerFeeRate;	}	protected synchronized void setMakerFeeRate(double makerFeeRate) {		this.makerFeeRate = makerFeeRate;	}	@Basic(optional = true)	public double getMarginFeeRate() {		return marginFeeRate;	}	protected synchronized void setMarginFeeRate(double marginFeeRate) {		this.marginFeeRate = marginFeeRate;	}	@Basic(optional = true)	protected double getMinimumOrderSize() {		return minimumOrderSize;	}	protected synchronized void setMinimumOrderSize(double minimumOrderSize) {		this.minimumOrderSize = minimumOrderSize;	}	@ManyToOne(optional = false)	@JoinColumn(name = "feeMethod")	private FeeMethod feeMethod;	public FeeMethod getFeeMethod() {		return feeMethod;	}	public synchronized void setFeeMethod(FeeMethod feeMethod) {		this.feeMethod = feeMethod;	}	@ManyToOne(optional = true)	private FeeMethod marginFeeMethod;	private double liquidation;	public FeeMethod getMarginFeeMethod() {		return marginFeeMethod;	}	protected synchronized void setMarginFeeMethod(FeeMethod marginFeeMethod) {		this.marginFeeMethod = marginFeeMethod;	}	@Basic(optional = true)	public boolean getFillsProvided() {		return fillsProvided;	}	protected synchronized void setFillsProvided(boolean fillsProvided) {		this.fillsProvided = fillsProvided;	}	@Basic(optional = false)	public int getMargin() {		return Math.max(margin, 1);	}	public synchronized void setMargin(int margin) {		this.margin = margin;	}	@Basic(optional = false)	public double getLiquidation() {		return liquidation;	}	public synchronized void setLiquidation(double liquidation) {		this.liquidation = liquidation;	}	@Override	public String toString() {		return symbol;	}	// JPA	protected Exchange() {	}	// @AssistedInject	// private Market(@Assisted Exchange exchange, @Assisted Listing listing, @Assisted("marketPriceBasis") double priceBasis,	//       @Assisted("marketVolumeBasis") double volumeBasis) {	protected synchronized void setSymbol(String symbol) {		this.symbol = symbol;	}	@AssistedInject	private Exchange(@Assisted String symbol, @Assisted int margin, @Assisted("makerFeeRate") double makerFeeRate,			@Assisted("takerFeeRate") double takerFeeRate, @Assisted("feeBasis") double feeBasis, @Assisted("orderBasis") double orderBasis,			@Assisted FeeMethod feeMethod, @Assisted boolean fillsProvided) {		this.symbol = symbol;		this.margin = margin;		this.takerFeeRate = takerFeeRate;		this.makerFeeRate = makerFeeRate;		this.feeBasis = feeBasis;		this.orderBasis = orderBasis;		this.feeMethod = feeMethod;		this.fillsProvided = fillsProvided;		this.balances = new ConcurrentHashMap<Asset, Balance>();	}	@AssistedInject	public Exchange(@Assisted String symbol, @Assisted int margin, @Assisted("makerFeeRate") double makerFeeRate, @Assisted("takerFeeRate") double takerFeeRate,			@Assisted("feeBasis") double feeBasis, @Assisted("orderBasis") double orderBasis, @Assisted("feeMethod") FeeMethod feeMethod,			@Assisted("marginFeeRate") double marginFeeRate, @Assisted("marginFeeMethod") FeeMethod marginFeeMethod,			@Assisted("minimumOrderSize") double minimumOrderSize, @Assisted boolean fillsProvided) {		this.symbol = symbol;		this.margin = margin;		this.takerFeeRate = takerFeeRate;		this.makerFeeRate = makerFeeRate;		this.minimumOrderSize = minimumOrderSize;		this.feeMethod = feeMethod;		this.marginFeeMethod = marginFeeMethod;		this.marginFeeRate = marginFeeRate;		this.fillsProvided = fillsProvided;		this.feeBasis = feeBasis;		this.orderBasis = orderBasis;		this.balances = new HashMap<Asset, Balance>();	}	@AssistedInject	public Exchange(@Assisted String symbol) {		//   return forSymbolOrCreate(symbol);		this.symbol = symbol;	}	private String symbol;	private int margin;	private double takerFeeRate;	private double makerFeeRate;	private double marginFeeRate;	private double minimumOrderSize;	private double feeBasis;	private double orderBasis;	private boolean fillsProvided;	public synchronized void addBalance(Balance balance) {		getBalances().put(balance.getAsset(), balance);		balance.setExchange(this);	}	public synchronized void removeBalance(Balance balance) {		getBalances().remove(balance.getAsset());		balance.setExchange(null);		//fill.setOrder(null);	}	public synchronized void removeBalances() {		for (Asset asset : getBalances().keySet())			getBalances().get(asset).setExchange(null);		getBalances().clear();		//  .remove(balance.getAsset());		//fill.setOrder(null);	}	@Override	public synchronized void persit() {		this.setPeristanceAction(PersistanceAction.NEW);		this.setRevision(this.getRevision() + 1);		log.debug("Exchange - Persist : Persit of Exchange " + this.getUuid() + " called from class " + Thread.currentThread().getStackTrace()[2]);		exchangeDao.persist(this);	}	@Override	public synchronized EntityBase refresh() {		return exchangeDao.refresh(this);	}	@Override	public synchronized void detach() {		exchangeDao.detach(this);		// TODO Auto-generated method stub	}	@Override	public synchronized void merge() {		try {			//   find();			this.setPeristanceAction(PersistanceAction.MERGE);			this.setRevision(this.getRevision() + 1);			log.debug("Exchange - Merge : Merge of Exchange " + this.getUuid() + " called from class " + Thread.currentThread().getStackTrace()[2]);			exchangeDao.merge(this);			//if (duplicate == null || duplicate.isEmpty())		} catch (Exception | Error ex) {			System.out.println("Unable to perform request in " + this.getClass().getSimpleName() + ":merge, full stack trace follows:" + ex);			// ex.printStackTrace();		}	}	@Nullable	@OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.MERGE)	//, mappedBy = "exchange")	@MapKeyJoinColumn(name = "asset")	public Map<Asset, Balance> getBalances() {		if (balances == null)			balances = new ConcurrentHashMap<Asset, Balance>();		return balances;	}	protected synchronized void setBalances(Map<Asset, Balance> balances) {		this.balances = balances;	}	@Override	@Transient	public Dao getDao() {		return exchangeDao;	}	@Override	@Transient	public synchronized void setDao(Dao dao) {		exchangeDao = (ExchangeJpaDao) dao;		// TODO Auto-generated method stub		//  return null;	}	@Override	public synchronized void delete() {		// TODO Auto-generated method stub	}	/*	 * @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((symbol == null) ? 0 : symbol.hashCode());	 * return result; }	 * @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() !=	 * obj.getClass()) { return false; } Exchange other = (Exchange) obj; if (symbol == null) { if (other.symbol != null) { return false; } } else if	 * (!symbol.equals(other.symbol)) { return false; } return true; }	 */	@Override	public synchronized void prePersist() {		if (getDao() != null) {			if (getBalances() != null) {				for (Balance balance : getBalances().values()) {					EntityBase dbBalance = null;					try {						dbBalance = getDao().find(balance.getClass(), balance.getId());						if (dbBalance != null) {							dbBalance = getDao().mergeEntities(false, balance);							//this.setListing((Listing) dbListing);						} else {							//getOrder().setPeristanceAction(PersistanceAction.NEW);							getDao().persistEntities(false, balance);						}					} catch (Throwable ex) {						if (dbBalance != null)							if (balance.getRevision() > dbBalance.getRevision()) {								//  getOrder().setPeristanceAction(PersistanceAction.MERGE);								try {									getDao().mergeEntities(false, balance);								} catch (Throwable e) {									// TODO Auto-generated catch block									e.printStackTrace();								}							} else {								//   getOrder().setPeristanceAction(PersistanceAction.NEW);								try {									getDao().persistEntities(false, balance);								} catch (Throwable e) {									// TODO Auto-generated catch block									e.printStackTrace();								}							}					}				}			}		}	}	@Override	public synchronized void postPersist() {		// TODO Auto-generated method stub	}	@Override	public synchronized void persitParents() {		// TODO Auto-generated method stub	}}